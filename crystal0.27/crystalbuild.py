#!/usr/bin/env python
"""Crystal Action Compiler
#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""
from __future__ import print_function
import os
import sys
import codecs
import subprocess

# crystalbuild.py is used to prepare files to run with the go proxy.
# After running the code your directory will look like this:
#   <target-dir>/:
#     exec          # Executable Binary
#                   # generated by `def build(...)`
#                   # compiled executable code or
#                   # script invoking uncompiled code (for node.js, ruby etc.)
#                   # eg.   #!/bin/bash
#                   #       cd <source-dir>
#                   #       exec crystal main__.cr
#
#   <source-dir>/:
#     exec          # User Action
#                   # generated by `def sources(...)`
#                   # source action code submitted by user
#
#     exec__.cr     # User Action - Processed
#                   # generated by `def sources(...)`
#                   # copy of `exec` file + included modifications (if any)
#
#     main__.cr     # Proxy Gluecode
#                   # generated by `def sources(...)`
#                   # a copy of <this-filename>.launcher.cr
#                   # allows the proxy to run user supplied action code
#                   # to test the launcher run `$ crystal main__.cr 3>&1`


def sources(launcher, source_dir, main):
    # copy the exec to exec.cr
    src = "%s/exec" % source_dir
    dst = "%s/exec__.cr" % source_dir
    if os.path.isfile(src) and not os.path.isfile(dst):
        body = ""
        with codecs.open(src, 'r', 'utf-8') as s:
            body = s.read()
        with codecs.open(dst, 'w', 'utf-8') as d:
            # Append anything to the file you'd like here:
            # line = "\nmodule.exports = "+main+"\n"
            # d.write(body+line)
            d.write(body)
            # print("Created: %s" % dst)

    launcher_file = "%s/main__.cr" % source_dir
    with codecs.open(launcher_file, 'w', 'utf-8') as d:
        with codecs.open(launcher, 'r', 'utf-8') as s:
            body = s.read()
            d.write(body)
            # print("Created: %s" % launcher_file)


def build(source_dir, target_file):
    # compile crystal program
    subprocess.check_output(["crystal", "build",
                                        "%s/main__.cr" % source_dir,
                                        "-o", target_file,
                                        "--release",
                                        "--no-debug"])

# Alternative: execute crystal program via command line
#     with codecs.open(target_file, 'w', 'utf-8') as d:
#         d.write("""#!/bin/bash
# cd %s
# exec crystal main__.cr
# """ % source_dir)
#     os.chmod(target_file, 0o755)
    # print("Created: %s" % target_file)


def main(argv):
    if len(argv) < 4:
        print("usage: <main-function> <source-dir> <target-dir>")
        sys.exit(1)

    main = argv[1]  # main function path
    source_dir = os.path.abspath(argv[2])  # source directory path
    target_file = os.path.abspath("%s/exec" % argv[3])  # target directory
    launcher = os.path.abspath(argv[0]+".launcher.cr")
    sources(launcher, source_dir, main)
    build(source_dir, target_file)

    if not os.path.isdir(source_dir):
        print("ERROR: %s does not exist" % source_dir)
        sys.exit(1)

    if not os.path.isfile(target_file):
        print("ERROR: %s does not exist" % target_file)
        sys.exit(1)

    if not os.path.isfile(launcher):
        print("ERROR: %s does not exist" % launcher)
        sys.exit(1)


if __name__ == '__main__':
    main(sys.argv)
